#include <cuda_runtime.h>
#include <curand.h>
#include <curand_kernel.h>
#include <thrust/device_vector.h>
#include <thrust/sort.h>
#include <thrust/unique.h>
#include <thrust/execution_policy.h>

// 定义 FisherProblem 结构体
struct FisherProblem {
    double* x0;
    double* w;
    double* u_val;
    double* b;
    int* col_ind;
    int* row_ptr;
    double* bounds;
    double power;
};

// 初始化随机数生成器
__global__ void setup_rng(curandState* state, unsigned long long seed, int nnz) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
    if (idx < nnz) {
        curand_init(seed, idx, 0, &state[idx]);
    }
}

__global__ void fill_rand(curandState* state, double* data, int nnz) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
    if (idx < nnz) {
        data[idx] = curand_uniform_double(&state[idx]) * 0.999 + 1e-6; // 生成 (1e-6, 1) 范围内的随机数
    }
}

// 生成 [0, n-1] 范围内的随机整数
__global__ void generate_random_integers(curandState* state, int* col_ind, int nnz, int n) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
    if (idx < nnz) {
        col_ind[idx] = static_cast<int>(curand_uniform_double(&state[idx]) * n);
    }
}

__global__ void unique_columns(int* col_ind, int* row_ptr, int m, int n) {
    int row = blockIdx.x;
    if (row >= m) return;

    int start = row_ptr[row];
    int end = row_ptr[row + 1];
    int num_cols = end - start;

    // 使用一个临时数组存储列索引
    extern __shared__ int shared_cols[];
    int* temp_cols = shared_cols;

    // 将列索引加载到共享内存
    for (int i = threadIdx.x; i < num_cols; i += blockDim.x) {
        temp_cols[threadIdx.x + i] = col_ind[start + i];
    }
    __syncthreads();

    // 简单的冒泡排序（适用于小数组）
    for (int i = 0; i < num_cols - 1; ++i) {
        for (int j = 0; j < num_cols - i - 1; ++j) {
            if (temp_cols[j] > temp_cols[j + 1]) {
                int temp = temp_cols[j];
                temp_cols[j] = temp_cols[j + 1];
                temp_cols[j + 1] = temp;
            }
        }
    }
    __syncthreads();

    // 去重
    int unique_count = 0;
    for (int i = 0; i < num_cols; ++i) {
        if (i == 0 || temp_cols[i] != temp_cols[i - 1]) {
            col_ind[start + unique_count] = temp_cols[i];
            unique_count++;
        }
    }
}
// 计算 u_sum_dim_1 和 vec_val
__global__ void compute_u_sum_dim_1_and_vec_val(double* u_val, int* row_ptr, double* b, double* u_sum_dim_1, double* vec_val, int m) {
    int row = blockIdx.x;
    if (row >= m) return;

    int start = row_ptr[row];
    int end = row_ptr[row + 1];
    double sum = 0.0;
    for (int i = start; i < end; ++i) {
        sum += u_val[i];
    }
    u_sum_dim_1[row] = sum;
    vec_val[row] = b[row] / max(sum, 1e-12); // 避免除零
}

// 计算 x0
__global__ void compute_x0(double* u_val, int* row_ptr, double* vec_val, double* x0, int m) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
    if (idx >= m) return;

    int row = idx;
    int start = row_ptr[row];
    int end = row_ptr[row + 1];
    for (int i = start; i < end; ++i) {
        x0[i] = vec_val[row] * u_val[i];
    }
}

void generate_problem_gpu(int m, int n, int nnz, FisherProblem &csr, double power = 1.0) {
    // 1. 分配设备内存
    cudaMalloc(&csr.x0,     nnz * sizeof(double));
    cudaMalloc(&csr.w,      nnz * sizeof(double));
    cudaMalloc(&csr.u_val,  nnz * sizeof(double));
    cudaMalloc(&csr.b,      m   * sizeof(double));
    cudaMalloc(&csr.col_ind, nnz * sizeof(int));
    cudaMalloc(&csr.row_ptr, (m+1) * sizeof(int));
    cudaMalloc(&csr.bounds, 3 * nnz * sizeof(double));
    double* d_u_sum_dim_1;
    double* d_vec_val;
    cudaMalloc(&d_u_sum_dim_1, m * sizeof(double));
    cudaMalloc(&d_vec_val, m * sizeof(double));
    csr.power = power;
    
        // 2. 随机数状态
    curandState *d_state;
    cudaMalloc(&d_state, nnz * sizeof(curandState));
    setup_rng<<<(nnz+255)/256, 256>>>(d_state, 1234ULL, nnz);

    // 3. 填充 x0, w, u_val 在 (1e-6, 1)
    fill_rand<<<(nnz+255)/256, 256>>>(d_state, csr.x0,    nnz);
    fill_rand<<<(nnz+255)/256, 256>>>(d_state, csr.w,     nnz);
    fill_rand<<<(nnz+255)/256, 256>>>(d_state, csr.u_val, nnz);

    // double* h_u_val = new double[nnz];
    // cudaMemcpy(h_u_val, csr.u_val, nnz * sizeof(double), cudaMemcpyDeviceToHost);
    // for (int i = 0; i < nnz; ++i) {
    //     printf("u_val[%d] = %f\n", i, h_u_val[i]);
    // }
    // delete[] h_u_val;

    // 4. 构造 row_ptr：每行 nnz/m 个非零（动态分配）
    int min_per_row = nnz / m;
    int extra = nnz - min_per_row * m;
    std::vector<int> h_row_ptr(m + 1);
    h_row_ptr[0] = 0;
    for (int i = 1; i <= m; ++i) {
        h_row_ptr[i] = h_row_ptr[i - 1] + min_per_row + (i <= extra ? 1 : 0);
    }
    cudaMemcpy(csr.row_ptr, h_row_ptr.data(), (m + 1) * sizeof(int), cudaMemcpyHostToDevice);

    // 5. 构造 col_ind：生成 [0, n-1] 范围内的随机整数
    generate_random_integers<<<(nnz+255)/256, 256>>>(d_state, csr.col_ind, nnz, n);

    // 6. 确保每行的列索引是唯一的
    unique_columns<<<(m+255)/256, 256>>>(csr.col_ind, csr.row_ptr, m, n);

    // 7. 生成 b：随机
    double* h_b = new double[m];
    std::fill(h_b, h_b + m, 0.25 * m);
    cudaMemcpy(csr.b, h_b, m * sizeof(double), cudaMemcpyHostToDevice);
    delete[] h_b;

    // 8. 构造 bounds：三行 [nbd; lb; ub]
    double* h_bounds = new double[3 * nnz];
    std::fill(h_bounds, h_bounds + nnz, 2.0); // nbd
    std::fill(h_bounds + nnz, h_bounds + 2 * nnz, 1e-12); // lb
    std::fill(h_bounds + 2 * nnz, h_bounds + 3 * nnz, 1.0); // ub
    cudaMemcpy(csr.bounds, h_bounds, 3 * nnz * sizeof(double), cudaMemcpyHostToDevice);
    delete[] h_bounds;

    // 9. 计算 u_sum_dim_1 和 vec_val
    compute_u_sum_dim_1_and_vec_val<<<(m+255)/256, 256>>>(csr.u_val, csr.row_ptr, csr.b, d_u_sum_dim_1, d_vec_val, m);
//     // 检查 u_sum_dim_1 的值
    double* h_u_sum_dim_1 = new double[m];
    cudaMemcpy(h_u_sum_dim_1, d_u_sum_dim_1, m * sizeof(double), cudaMemcpyDeviceToHost);
    for (int i = 0; i < m; ++i) {
        printf("u_sum_dim_1[%d] = %f\n", i, h_u_sum_dim_1[i]);
    }
    delete[] h_u_sum_dim_1;

    // 检查 vec_val 的值
    double* h_vec_val = new double[m];
    cudaMemcpy(h_vec_val, d_vec_val, m * sizeof(double), cudaMemcpyDeviceToHost);
    for (int i = 0; i < m; ++i) {
        printf("vec_val[%d] = %f\n", i, h_vec_val[i]);
    }
    delete[] h_vec_val;

    double* h_b1 = new double[m];
    cudaMemcpy(h_b1, csr.b, m * sizeof(double), cudaMemcpyDeviceToHost);
    for (int i = 0; i < m; ++i) {
        printf("b[%d] = %f\n", i, h_b[i]);
    }
    delete[] h_b1;
        // 10. 计算 x0
    compute_x0<<<(nnz+255)/256, 256>>>(csr.u_val, csr.row_ptr, d_vec_val, csr.x0, nnz);

    // 释放临时内存
    cudaFree(d_state);
    cudaFree(d_u_sum_dim_1);
    cudaFree(d_vec_val);
}
#include <iostream>
#include <cuda_runtime.h>
#include "fisher_problem.h"
#include "fisher_func.h"
int main() {
    const int m_dim = 100;
    const int n_dim = 100;
    const int nnz   = 10000;

    FisherProblem csr;
    generate_problem_gpu(m_dim, n_dim, nnz, csr, 1.0);

    double *h_x0 = new double[nnz];
    cudaMemcpy(h_x0, csr.x0, nnz*sizeof(double), cudaMemcpyDeviceToHost);
    std::cout << "First 5 x0: ";
    for (int i = 0; i <5; ++i) std::cout << h_x0[i] << " ";
    std::cout << "\n";
    
    double *utility = new double[m_dim];
    double *d_utility;
    cudaMalloc(&d_utility, m_dim * sizeof(double));
    double *p;
    cudaMalloc(&p, n_dim * sizeof(double));
    double *tmp_objective;
    cudaMalloc(&tmp_objective, m_dim * sizeof(double));
    launch_utility_csr<double>(
        m_dim, csr.x0, csr.u_val, csr.row_ptr, d_utility, csr.power);
    launch_objective_csr<double>(
        m_dim, csr.x0, csr.u_val, csr.w, csr.row_ptr, csr.col_ind, 
        csr.power, tmp_objective, p, 1.0, csr.x0);
    double *h_objective = new double[m_dim];
    cudaMemcpy(h_objective, tmp_objective, m_dim * sizeof(double), cudaMemcpyDeviceToHost);
    std::cout << "Objective function launched successfully.\n";
    std::cout << "Objective function value: "<< h_objective[0] << "\n";
    double *h_utility = new double[m_dim];
    cudaMemcpy(h_utility, d_utility, m_dim * sizeof(double), cudaMemcpyDeviceToHost);
    std::cout << "First 5 utility: ";
    for (int i = 0; i < 100; ++i) std::cout << h_utility[i] << " ";
    std::cout << "\n";
    cudaFree(csr.x0); cudaFree(csr.w); cudaFree(csr.u_val);
    cudaFree(csr.b); cudaFree(csr.col_ind); cudaFree(csr.row_ptr);
    cudaFree(csr.bounds);
    delete [] h_x0;
    return 0;
}